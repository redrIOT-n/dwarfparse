//remove these headers
//
//#include "parse.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <elf.h>
#include <stdbool.h>

#include <sys/types.h>

struct elf_header{

  Elf64_Ehdr ehdr; /* elf header */
  ssize_t ehdr_size;  /* size of the elf header */
};

struct phdr_table{

  Elf64_Phdr *phdr_table; /* program header table */
  int no_of_entries;  /* no of program headers */
};

struct string_table{

  int index_string_tab; /* index of section which holds section header name string table */
  off_t string_tab_offset;  /* string table offset from begining of the file */
  int strtab_entries;     /*no of entries in string table, no of strings */
  char **content; /* string table data */
  int string_tab_size; /* string table length */
};

struct shdr_table{

  Elf64_Shdr *shdr_table; /* section header table */
 
  /*
   * structures containing each usefull section information
   */
  struct string_table string_table;  /* string table structure */

  int no_of_entries; /* no of section headers */
};

typedef struct {

  char *filename; /* filename of the elf binary */
  FILE *fh; /* file structure to keep read data */
  
  /*
   * elf header / header table structures
   */
  struct elf_header elf_header; 
  struct phdr_table phdrtab;
  struct shdr_table shdrtab;

} ElfData;

void exit_code(char *msg, int code){

  puts(msg);
  exit(code);
}

char **parse_strings(char *buffer, int entries, int size){

  char **parsed_string = calloc(sizeof(char *), entries);
  if(!parsed_string) return NULL;

  int entry_i = 0;
  for (int i = 0; i < size; ++i){

    if(buffer[i] != '\0'){

      parsed_string[entry_i] = &buffer[i];
      while(buffer[i] != '\0') ++i; 
      ++entry_i;
    }
    else
      while(buffer[i] == '\0') i++;
  }
  return parsed_string;
}

int get_no_of_entries(char *buffer, int size){

  int strings = 0;
  for (int i = 1; i < size; i++){

    if(buffer[i] == '\0')
      ++strings;
    else 
      continue;
  }
  return strings;
}

void print_section_names(ElfData *data){

  /*get the section header table index to get the string table. ehdr.e_shstrndx containts the index of shstrtab table*/
  data->shdrtab.string_table.index_string_tab = data->elf_header.ehdr.e_shstrndx;

  /*use section header index to access access corresponding section;'s shdr structure and use sh_offset to get the offset of the string table */
  data->shdrtab.string_table.string_tab_offset = data->shdrtab.shdr_table[data->shdrtab.string_table.index_string_tab].sh_offset;
  
  /* seek to that offset */
  fseek(data->fh, data->shdrtab.string_table.string_tab_offset, SEEK_SET);
  
  /* set size of the  string table using sh_size */
  data->shdrtab.string_table.string_tab_size = data->shdrtab.shdr_table[data->shdrtab.string_table.index_string_tab].sh_size;

  /* allocate a buffer with size sh_size, then read shstrtab into that buffer */
  char *buffer = malloc(data->shdrtab.string_table.string_tab_size);
  if(!buffer) exit_code("malloc failed", EXIT_FAILURE);
  
  if(fread(buffer, 1, data->shdrtab.string_table.string_tab_size, data->fh) < (unsigned long)data->shdrtab.string_table.string_tab_size) 
    exit_code("fread failed", EXIT_FAILURE);
 
  /* 
   * after reading, we need tp get the exact number of strings in that table. this is also possible using something like 
   * e_shnum, which gives us number of sections. number of sections == no of strings in shstrtab
   */
  data->shdrtab.string_table.strtab_entries = get_no_of_entries(buffer, data->shdrtab.string_table.string_tab_size); 

  printf("%d\t%d\n", data->shdrtab.string_table.string_tab_size, data->shdrtab.string_table.strtab_entries);

  /* read to (char *) buffer , sh_size of bytes from current position (section .strtab offset)) */
  data->shdrtab.string_table.content = parse_strings(buffer, data->shdrtab.string_table.strtab_entries, data->shdrtab.string_table.string_tab_size);

  for (int i = 0; i < data->shdrtab.string_table.no_of_entries; i++){

    printf("%d %s\n", i, data->shdrtab.string_table.content[i]);
  }
  printf("%d\n", data->shdrtab.no_of_entries);
  printf("%d\n", data->shdrtab.string_table.no_of_entries;
}

bool check_elf(FILE *fh){

  uint8_t buf[4];
  
  fread(buf, sizeof(uint8_t), 3, fh);
  
  if(buf[0] == EI_MAG0 && buf[1] == EI_MAG1 && buf[2] == EI_MAG2 && buf[3] == EI_MAG3) return true;

  return false;
}

void assign_headers(ElfData *data){

  //there is some error with check_elf function
  //if(!check_elf(data->fh)) exit_code("file is not an elf binary");
  
  /* assigning ehdr with data read from the binary */
  data->elf_header.ehdr_size = sizeof(Elf64_Ehdr);
  if(fread(&data->elf_header.ehdr, data->elf_header.ehdr_size, 1, data->fh) < 1) 
    exit_code("unable to read file", EXIT_FAILURE);
  

  /* assigning phdr with data read from binary using ehdr->e_phoff */ 
  data->phdrtab.no_of_entries = data->elf_header.ehdr.e_phnum;
  
  data->phdrtab.phdr_table = calloc(data->phdrtab.no_of_entries, sizeof(Elf64_Phdr));
  if(!data->phdrtab.phdr_table) exit_code("calloc failed", EXIT_FAILURE);

  fseek(data->fh, data->elf_header.ehdr.e_phoff, SEEK_SET); //seeking file pointer to position where program header table begins

  if(fread(data->phdrtab.phdr_table, sizeof(Elf64_Phdr), data->phdrtab.no_of_entries, data->fh) < (unsigned long)data->phdrtab.no_of_entries) //reading from that location to allocated space in heap
    exit_code("could not read program header table", EXIT_FAILURE);


  /* assigning shdr with data read from binary using ehdr->e_shoff */
  data->shdrtab.no_of_entries = data->elf_header.ehdr.e_shnum;

  data->shdrtab.shdr_table = calloc(data->shdrtab.no_of_entries, sizeof(Elf64_Shdr));
  if(!data->shdrtab.shdr_table) exit_code("calloc failed", EXIT_FAILURE);

  fseek(data->fh, data->elf_header.ehdr.e_shoff, SEEK_SET);

  if(fread(data->shdrtab.shdr_table, sizeof(Elf64_Shdr), data->shdrtab.no_of_entries, data->fh) < (unsigned long)data->shdrtab.no_of_entries)
    exit_code("could not read section header table", EXIT_FAILURE);

}

FILE *open_file(char *filename){

  FILE *local = fopen(filename, "rb");
  if(!local)
    exit_code("coud not open binary file", EXIT_FAILURE);

  return local;
}

int main(void){

  ElfData data;
  data.filename = "dbg";
  printf("%s\n", data.filename);

  data.fh = open_file(data.filename);
  assign_headers(&data);

  print_section_names(&data);
  //find_section(&data, ".debug_info");
}
